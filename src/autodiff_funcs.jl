####################
# Helper Functions #
####################
# Use @generated functions to essentially cache the
# zeros/epsilon components generated by the input type.
# This caching allows for a higher degree of efficieny 
# when calculating derivatives of f at multiple points, 
# as these values get reused rather than instantiated 
# every time.
#
# This method has the potential to incur a large memory 
# cost (and could even be considered a leak) if a 
# downstream program use many *different* epsilon components, 
# though I can't think of any use cases in which that would be 
# relevant.

@generated function zero_partials{N,T}(::Type{NDualVec{N,T}})
    result = zeros(T, N)
    return :($result)
end

@generated function zero_partials{N,T}(::Type{NDualTup{N,T}})
    z = zero(T)
    result = ntuple(i->z, Val{N})
    return :($result)
end

@generated function zero_partials{N,T,D}(::Type{FADHessian{N,T,D}})
    result = zeros(T, halfhesslen(N))
    return :($result)
end

@generated function zero_partials{N,T,D}(::Type{FADHessian{N,T,D}})
    result = zeros(T, halftenslen(N))
    return :($result) 
end

@generated function eps_chunk{N,T}(::Type{NDualVec{N,T}})
    dus_arr = Array(Vector{T}, N)
    for i in 1:length(dus_arr)
        dus_arr[i] = setindex!(zeros(T,N), one(T), i)
    end
    return :($dus_arr)
end

@generated function eps_chunk{N,T}(::Type{NDualTup{N,T}})
    dus_arr = Array(NTuple{N,T}, N)
    z = zero(T)
    o = one(T)
    for i in 1:length(dus_arr)
        dus_arr[i] = ntuple(x -> ifelse(x == i, o, z), Val{N})
    end
    return :($dus_arr)
end

resulttype{N,T,RT}(::Type{NDualTup{N,T}}, ::Type{RT}) = NDualTup{N,RT}
resulttype{N,T,RT}(::Type{NDualVec{N,T}}, ::Type{RT}) = NDualVec{N,RT}

####################
# Taking Gradients #
####################
function gradient!{D<:NDual,T,S}(f::Function,
                                 x::Vector{T},
                                 output::Vector{S},
                                 dualvec::Vector{D}) 
    xlen = length(x)
    N = neps(D)

    @assert xlen == length(output) "The output array must be the same length as x"
    @assert xlen == length(dualvec) "The coefficient type of $D must match eltype(input)"
    @assert T == eltype(D) "The eltype of the dual numbers used ($D) must match eltype of input vector"
    @assert xlen % N == 0 "Length of input vector is indivisible by the number of epsilon components (length(x) = $k, neps(eltype(dualvec)) = $N)"

    ResultDualType = resulttype(D,S)

    epsilons = eps_chunk(D)

    # We can do less work filling and
    # zeroing out dualvec if xlen == N
    if xlen == N
        @inbounds @simd for i in 1:xlen
            dualvec[i] = D(x[i], epsilons[i])
        end

        result::ResultDualType = f(dualvec)
        
        @inbounds @simd for i in 1:xlen
            output[i] = epsilon(result, i)
        end
    else
        zeps = zero_partials(D)

        # load x[i]-valued NDuals into dualvec 
        @inbounds @simd for i in 1:xlen
            dualvec[i] = D(x[i], zeps)
        end

        for i in 1:N:xlen
            # load dual numbers with single
            # epsilon components into current 
            # chunk of dualvec
            @inbounds @simd for j in 0:(N-1)
                m = i+j
                dualvec[m] = D(x[m], epsilons[j+1])
            end

            chunk_result::ResultDualType = f(dualvec)

            # load resultant epsilon components
            # into output, replacing them with 
            # zeros in dualvec
            @inbounds @simd for j in 0:(N-1)
                m = i+j
                output[m] = epsilon(chunk_result, j+1)
                dualvec[m] = D(x[m], zeps)
            end
        end
    end

    return output
end

gradient!{D<:NDual}(f::Function, x::Vector, output::Vector, ::Type{D}) = gradient!(f, x, output, similar(x, D))
gradient!{D<:NDual}(f::Function, x::Vector, dualvec::Vector{D}) = gradient!(f, x, similar(x), dualvec)

gradient{D<:NDual}(f::Function, x::Vector, ::Type{D}) = gradient!(f, x, similar(x), D)

function gradient_func{D<:NDual}(f::Function, xlen::Int, ::Type{D}, mutates=true)
    dualvec = Vector{D}(xlen)
    if mutates
        gradf!(x::Vector, output::Vector) = gradient!(f, x, output, dualvec)
        return gradf!
    else
        gradf(x::Vector) = gradient!(f, x, dualvec)
        return gradf
    end
end

###################
# Taking Hessians #
###################
function hessian!{D<:NDual,N,T,S}(f::Function,
                                  x::Vector{T},
                                  output::Matrix{S},
                                  hessvec::Vector{FADHessian{N,T,D}}) 
    xlen = length(x)

    @assert xlen == size(output,1) == size(output,2) "The output matrix must have size (length(input), length(input))"
    @assert xlen == length(hessvec) "The FADHessian vector must be the same length as the input"
    @assert xlen % N == 0 "Length of input is indivisible by the number of epsilon components (length(x) = $k, neps(eltype(hessvec)) = $N)"

    ResultHessType = FADHessian{N,S,resulttype(D,S)}

    epsilons = eps_chunk(D)
    zhess = zero_partials(eltype(hessvec))

    # We can do less work filling and
    # zeroing out hessvec if xlen == N
    if xlen == N
        @inbounds @simd for i in 1:xlen
            hessvec[i] = FADHessian(D(x[i], epsilons[i]), zhess)
        end

        result::ResultHessType = f(hessvec)

        hessian!(result, output)
    else
        zeps = zero_partials(D)

        # load x[i]-valued FADHessians into hessvec 
        @inbounds @simd for i in 1:xlen
            hessvec[i] = FADHessian(D(x[i], zeps), zhess)
        end

        for m in 1:N:xlen
            # load FADHessians with single
            # epsilon components into current
            # chunk of hessvec
            @inbounds @simd for i in 0:(N-1)
                k = m + i
                hessvec[k] = FADHessian(D(x[k], epsilons[i+1]), zhess)
            end

            chunk_result::ResultHessType = f(hessvec)

            # load resultant hessian components
            # into output, replacing them with 
            # zeros in hessvec
            q = 1
            for i in m:(m+N)
                for j in 1:i
                    k = m + q
                    val = hess(chunk_result, q)
                    output[i, j] = val
                    output[j, i] = val
                    hessvec[k] = FADHessian(D(x[k], zeps), zhess)
                    q += 1
                end
            end
        end
    end

    return output
end

function hessian!{D<:NDual}(f::Function, x::Vector, output::Matrix, ::Type{D})
    return hessian!(f, x, output, similar(x, FADHessian{neps(D),eltype(D),D}))
end

function hessian!{F<:FADHessian,T}(f::Function, x::Vector{T}, hessvec::Vector{F})
    xlen = length(x)
    return hessian!(f, x, Array(T, xlen, xlen), hessvec)
end

function hessian{D<:NDual,T}(f::Function, x::Vector{T}, ::Type{D})
    xlen = length(x)
    return hessian!(f, x, Array(T, xlen, xlen), D)
end

function hessian_func{D<:NDual}(f::Function, xlen::Int, ::Type{D}, mutates=true)
    hessvec = Vector{FADHessian{neps(D),eltype(D),D}}(xlen)
    if mutates
        hessf!(x::Vector, output::Matrix) = hessian!(f, x, output, hessvec)
        return hessf!
    else
        hessf(x::Vector) = hessian!(f, x, hessvec)
        return hessf
    end
end

##################
# Taking Tensors #
##################
function tensor!{D<:NDual,N,T,S}(f::Function,
                                 x::Vector{T},
                                 output::Array{S,3},
                                 tensvec::Vector{FADTensor{N,T,D}}) 
    xlen = length(x)

    @assert (xlen,xlen,xlen) == size(output) "The output array must have size (length(input), length(input), length(input))"
    @assert xlen == length(tensvec) "The FADTensor vector must be the same length as the input"
    @assert xlen % N == 0 "Length of input is indivisible by the number of epsilon components (length(x) = $k, neps(eltype(hessvec)) = $N)"

    ResultTensType = FADTensor{N,S,resulttype(D,S)}

    epsilons = eps_chunk(D)
    zhess = zero_partials(FADHessian{N,T,D})
    ztens = zero_partials(eltype(tensvec))

    # We can do less work filling and
    # zeroing out tensvec if xlen == N
    if xlen == N
        @inbounds @simd for i in 1:xlen
            tensvec[i] = FADTensor(FADHessian(D(x[i], epsilons[i]), zhess), ztens)
        end

        result::ResultTensType = f(tensvec)

        tensor!(result, output)
    else
        zeps = zero_partials(D)

        # load x[i]-valued FADTensors into tensvec 
        @inbounds @simd for i in 1:xlen
            tensvec[i] = FADTensor(FADHessian(D(x[i], zeps[i]), zhess), ztens)
        end

        for m in 1:N:xlen
            # load FADTensors with single
            # epsilon components into current
            # chunk of tensvec
            @inbounds @simd for i in 0:(N-1)
                k = m + i
                tensvec[k] = FADTensor(FADHessian(D(x[k], epsilons[i+1]), zhess), ztens)
            end

            chunk_result::ResultTensType = f(tensvec)

            # load resultant tensor components
            # into output, replacing them with 
            # zeros in tensvec
            q = 0
            for k in m:(m+N)
                for i in k:(m+N)
                    for j in k:i 
                        n = m + q
                        val = tens(chunk_result, q+1)
                        output[i, j, k] = val
                        output[j, i, k] = val
                        output[j, k, i] = val
                        tensvec[n] = FADHessian(D(x[n], zeps), zhess)
                        q += 1
                    end
                end
            end
        end
    end

    return output
end

function tensor!{D<:NDual,T}(f::Function, x::Vector, output::Array{T,3}, ::Type{D})
    return tensor!(f, x, output, similar(x, FADTensor{neps(D),eltype(D),D}))
end

function tensor!{F<:FADTensor,T}(f::Function, x::Vector{T}, tensvec::Vector{F})
    xlen = length(x)
    return tensor!(f, x, Array(T, xlen, xlen, xlen), tensvec)
end

function tensor{D<:NDual,T}(f::Function, x::Vector{T}, ::Type{D})
    xlen = length(x)
    return tensor!(f, x, Array(T, xlen, xlen, xlen), D)
end

function tensor_func{D<:NDual}(f::Function, xlen::Int, ::Type{D}, mutates=true)
    tensvec = Vector{FADTensor{neps(D),eltype(D),D}}(xlen)
    if mutates
        tensf!{T}(x::Vector, output::Array{T,3}) = tensor!(f, x, output, tensvec)
        return tensf!
    else
        tensf(x::Vector) = tensor!(f, x, tensvec)
        return tensf
    end
end